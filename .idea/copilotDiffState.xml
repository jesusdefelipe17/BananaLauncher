<?xml version="1.0" encoding="UTF-8"?>
<project version="4">
  <component name="CopilotDiffPersistence">
    <option name="pendingDiffs">
      <map>
        <entry key="$PROJECT_DIR$/app/src/main/java/com/example/afo/achievements/AchievementsManager.kt">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/app/src/main/java/com/example/afo/achievements/AchievementsManager.kt" />
              <option name="updatedContent" value="package com.example.afo.achievements&#10;&#10;import android.content.Context&#10;import kotlinx.coroutines.flow.MutableStateFlow&#10;import kotlinx.coroutines.flow.asStateFlow&#10;import org.json.JSONArray&#10;import org.json.JSONObject&#10;&#10;data class Achievement(&#10;    val id: String,&#10;    val title: String,&#10;    val description: String,&#10;    val icon: String, // emoji o nombre de icono&#10;    val isUnlocked: Boolean = false,&#10;    val unlockedAt: Long? = null,&#10;    val progress: Int = 0,&#10;    val maxProgress: Int = 1&#10;)&#10;&#10;data class GameStats(&#10;    val gameName: String,&#10;    val platform: String,&#10;    val totalPlayTime: Long = 0, // en milisegundos&#10;    val lastPlayed: Long = 0,&#10;    val timesOpened: Int = 0,&#10;    val firstPlayed: Long = System.currentTimeMillis()&#10;)&#10;&#10;class AchievementsManager(private val context: Context) {&#10;    &#10;    private val prefs = context.getSharedPreferences(&quot;achievements_prefs&quot;, Context.MODE_PRIVATE)&#10;    &#10;    private val _achievements = MutableStateFlow&lt;List&lt;Achievement&gt;&gt;(emptyList())&#10;    val achievements = _achievements.asStateFlow()&#10;    &#10;    private val _gameStats = MutableStateFlow&lt;List&lt;GameStats&gt;&gt;(emptyList())&#10;    val gameStats = _gameStats.asStateFlow()&#10;    &#10;    private val _totalPlayTime = MutableStateFlow(0L)&#10;    val totalPlayTime = _totalPlayTime.asStateFlow()&#10;    &#10;    private val _gamesPlayed = MutableStateFlow(0)&#10;    val gamesPlayed = _gamesPlayed.asStateFlow()&#10;    &#10;    init {&#10;        loadAchievements()&#10;        loadGameStats()&#10;        initializeDefaultAchievements()&#10;    }&#10;    &#10;    private fun initializeDefaultAchievements() {&#10;        val defaultAchievements = listOf(&#10;            Achievement(&#10;                id = &quot;first_game&quot;,&#10;                title = &quot;Primer Paso&quot;,&#10;                description = &quot;Abre tu primer juego&quot;,&#10;                icon = &quot;&quot;,&#10;                maxProgress = 1&#10;            ),&#10;            Achievement(&#10;                id = &quot;collector&quot;,&#10;                title = &quot;Coleccionista&quot;,&#10;                description = &quot;Ten 10 juegos en tu biblioteca&quot;,&#10;                icon = &quot;&quot;,&#10;                maxProgress = 10&#10;            ),&#10;            Achievement(&#10;                id = &quot;time_traveler&quot;,&#10;                title = &quot;Viajero del Tiempo&quot;,&#10;                description = &quot;Juega durante 10 horas en total&quot;,&#10;                icon = &quot;⏰&quot;,&#10;                maxProgress = 36000000 // 10 horas en ms&#10;            ),&#10;            Achievement(&#10;                id = &quot;marathon&quot;,&#10;                title = &quot;Maratonista&quot;,&#10;                description = &quot;Juega durante 50 horas en total&quot;,&#10;                icon = &quot;&quot;,&#10;                maxProgress = 180000000 // 50 horas en ms&#10;            ),&#10;            Achievement(&#10;                id = &quot;dedicated&quot;,&#10;                title = &quot;Dedicado&quot;,&#10;                description = &quot;Juega durante 7 días seguidos&quot;,&#10;                icon = &quot;&quot;,&#10;                maxProgress = 7&#10;            ),&#10;            Achievement(&#10;                id = &quot;variety&quot;,&#10;                title = &quot;Variedad&quot;,&#10;                description = &quot;Juega 20 juegos diferentes&quot;,&#10;                icon = &quot;&quot;,&#10;                maxProgress = 20&#10;            ),&#10;            Achievement(&#10;                id = &quot;favorite_five&quot;,&#10;                title = &quot;Los Favoritos&quot;,&#10;                description = &quot;Marca 5 juegos como favoritos&quot;,&#10;                icon = &quot;⭐&quot;,&#10;                maxProgress = 5&#10;            ),&#10;            Achievement(&#10;                id = &quot;speed_runner&quot;,&#10;                title = &quot;Speedrunner&quot;,&#10;                description = &quot;Abre 50 juegos en total&quot;,&#10;                icon = &quot;⚡&quot;,&#10;                maxProgress = 50&#10;            ),&#10;            Achievement(&#10;                id = &quot;night_owl&quot;,&#10;                title = &quot;Búho Nocturno&quot;,&#10;                description = &quot;Juega después de medianoche&quot;,&#10;                icon = &quot;&quot;,&#10;                maxProgress = 1&#10;            ),&#10;            Achievement(&#10;                id = &quot;early_bird&quot;,&#10;                title = &quot;Madrugador&quot;,&#10;                description = &quot;Juega antes de las 6 AM&quot;,&#10;                icon = &quot;&quot;,&#10;                maxProgress = 1&#10;            )&#10;        )&#10;        &#10;        // Solo agregar achievements que no existen&#10;        val existingIds = _achievements.value.map { it.id }&#10;        val newAchievements = defaultAchievements.filter { it.id !in existingIds }&#10;        &#10;        if (newAchievements.isNotEmpty()) {&#10;            _achievements.value = _achievements.value + newAchievements&#10;            saveAchievements()&#10;        }&#10;    }&#10;    &#10;    fun recordGameOpened(gameName: String, platform: String) {&#10;        val stats = _gameStats.value.toMutableList()&#10;        val existingIndex = stats.indexOfFirst { it.gameName == gameName }&#10;        &#10;        val currentTime = System.currentTimeMillis()&#10;        &#10;        if (existingIndex &gt;= 0) {&#10;            val existing = stats[existingIndex]&#10;            stats[existingIndex] = existing.copy(&#10;                lastPlayed = currentTime,&#10;                timesOpened = existing.timesOpened + 1&#10;            )&#10;        } else {&#10;            stats.add(&#10;                GameStats(&#10;                    gameName = gameName,&#10;                    platform = platform,&#10;                    lastPlayed = currentTime,&#10;                    timesOpened = 1&#10;                )&#10;            )&#10;        }&#10;        &#10;        _gameStats.value = stats&#10;        _gamesPlayed.value = stats.size&#10;        saveGameStats()&#10;        &#10;        // Verificar logros&#10;        checkAchievements()&#10;    }&#10;    &#10;    fun recordPlayTime(gameName: String, playTimeMs: Long) {&#10;        val stats = _gameStats.value.toMutableList()&#10;        val existingIndex = stats.indexOfFirst { it.gameName == gameName }&#10;        &#10;        if (existingIndex &gt;= 0) {&#10;            val existing = stats[existingIndex]&#10;            stats[existingIndex] = existing.copy(&#10;                totalPlayTime = existing.totalPlayTime + playTimeMs&#10;            )&#10;        }&#10;        &#10;        _gameStats.value = stats&#10;        _totalPlayTime.value = stats.sumOf { it.totalPlayTime }&#10;        saveGameStats()&#10;        &#10;        checkAchievements()&#10;    }&#10;    &#10;    fun updateFavoritesCount(count: Int) {&#10;        updateAchievementProgress(&quot;favorite_five&quot;, count)&#10;    }&#10;    &#10;    private fun checkAchievements() {&#10;        val stats = _gameStats.value&#10;        val totalGames = stats.size&#10;        val totalTime = stats.sumOf { it.totalPlayTime }&#10;        val totalOpened = stats.sumOf { it.timesOpened }&#10;        &#10;        // Primer juego&#10;        if (totalGames &gt; 0) {&#10;            unlockAchievement(&quot;first_game&quot;)&#10;        }&#10;        &#10;        // Coleccionista&#10;        updateAchievementProgress(&quot;collector&quot;, totalGames)&#10;        &#10;        // Tiempo de juego&#10;        updateAchievementProgress(&quot;time_traveler&quot;, totalTime.toInt())&#10;        updateAchievementProgress(&quot;marathon&quot;, totalTime.toInt())&#10;        &#10;        // Variedad&#10;        updateAchievementProgress(&quot;variety&quot;, totalGames)&#10;        &#10;        // Speedrunner&#10;        updateAchievementProgress(&quot;speed_runner&quot;, totalOpened)&#10;        &#10;        // Verificar hora del día&#10;        val hour = java.util.Calendar.getInstance().get(java.util.Calendar.HOUR_OF_DAY)&#10;        if (hour &gt;= 0 &amp;&amp; hour &lt; 6) {&#10;            unlockAchievement(&quot;early_bird&quot;)&#10;        }&#10;        if (hour &gt;= 0 &amp;&amp; hour &lt; 6 || hour &gt;= 22) {&#10;            unlockAchievement(&quot;night_owl&quot;)&#10;        }&#10;        &#10;        // Verificar días consecutivos&#10;        checkConsecutiveDays()&#10;    }&#10;    &#10;    private fun checkConsecutiveDays() {&#10;        val lastPlayedDate = prefs.getLong(&quot;last_played_date&quot;, 0)&#10;        val today = System.currentTimeMillis() / (1000 * 60 * 60 * 24)&#10;        val lastDay = lastPlayedDate / (1000 * 60 * 60 * 24)&#10;        &#10;        if (today - lastDay == 1L) {&#10;            // Día consecutivo&#10;            val streak = prefs.getInt(&quot;play_streak&quot;, 0) + 1&#10;            prefs.edit().putInt(&quot;play_streak&quot;, streak).apply()&#10;            updateAchievementProgress(&quot;dedicated&quot;, streak)&#10;        } else if (today &gt; lastDay + 1) {&#10;            // Se rompió la racha&#10;            prefs.edit().putInt(&quot;play_streak&quot;, 1).apply()&#10;        }&#10;        &#10;        prefs.edit().putLong(&quot;last_played_date&quot;, System.currentTimeMillis()).apply()&#10;    }&#10;    &#10;    private fun updateAchievementProgress(achievementId: String, progress: Int) {&#10;        val achievements = _achievements.value.toMutableList()&#10;        val index = achievements.indexOfFirst { it.id == achievementId }&#10;        &#10;        if (index &gt;= 0) {&#10;            val achievement = achievements[index]&#10;            if (!achievement.isUnlocked &amp;&amp; progress &gt;= achievement.maxProgress) {&#10;                achievements[index] = achievement.copy(&#10;                    isUnlocked = true,&#10;                    progress = achievement.maxProgress,&#10;                    unlockedAt = System.currentTimeMillis()&#10;                )&#10;                _achievements.value = achievements&#10;                saveAchievements()&#10;            } else if (!achievement.isUnlocked) {&#10;                achievements[index] = achievement.copy(progress = progress)&#10;                _achievements.value = achievements&#10;                saveAchievements()&#10;            }&#10;        }&#10;    }&#10;    &#10;    private fun unlockAchievement(achievementId: String) {&#10;        val achievements = _achievements.value.toMutableList()&#10;        val index = achievements.indexOfFirst { it.id == achievementId }&#10;        &#10;        if (index &gt;= 0 &amp;&amp; !achievements[index].isUnlocked) {&#10;            achievements[index] = achievements[index].copy(&#10;                isUnlocked = true,&#10;                progress = achievements[index].maxProgress,&#10;                unlockedAt = System.currentTimeMillis()&#10;            )&#10;            _achievements.value = achievements&#10;            saveAchievements()&#10;        }&#10;    }&#10;    &#10;    fun getUnlockedAchievements(): List&lt;Achievement&gt; {&#10;        return _achievements.value.filter { it.isUnlocked }&#10;    }&#10;    &#10;    fun getUnlockedPercentage(): Float {&#10;        val total = _achievements.value.size&#10;        if (total == 0) return 0f&#10;        val unlocked = _achievements.value.count { it.isUnlocked }&#10;        return (unlocked.toFloat() / total.toFloat()) * 100f&#10;    }&#10;    &#10;    fun getMostPlayedGames(limit: Int = 5): List&lt;GameStats&gt; {&#10;        return _gameStats.value&#10;            .sortedByDescending { it.totalPlayTime }&#10;            .take(limit)&#10;    }&#10;    &#10;    fun getRecentGames(limit: Int = 5): List&lt;GameStats&gt; {&#10;        return _gameStats.value&#10;            .sortedByDescending { it.lastPlayed }&#10;            .take(limit)&#10;    }&#10;    &#10;    private fun saveAchievements() {&#10;        val jsonArray = JSONArray()&#10;        _achievements.value.forEach { achievement -&gt;&#10;            val jsonObject = JSONObject().apply {&#10;                put(&quot;id&quot;, achievement.id)&#10;                put(&quot;title&quot;, achievement.title)&#10;                put(&quot;description&quot;, achievement.description)&#10;                put(&quot;icon&quot;, achievement.icon)&#10;                put(&quot;isUnlocked&quot;, achievement.isUnlocked)&#10;                put(&quot;unlockedAt&quot;, achievement.unlockedAt ?: 0)&#10;                put(&quot;progress&quot;, achievement.progress)&#10;                put(&quot;maxProgress&quot;, achievement.maxProgress)&#10;            }&#10;            jsonArray.put(jsonObject)&#10;        }&#10;        prefs.edit().putString(&quot;achievements&quot;, jsonArray.toString()).apply()&#10;    }&#10;    &#10;    private fun loadAchievements() {&#10;        val json = prefs.getString(&quot;achievements&quot;, null) ?: return&#10;        try {&#10;            val jsonArray = JSONArray(json)&#10;            val achievements = mutableListOf&lt;Achievement&gt;()&#10;            for (i in 0 until jsonArray.length()) {&#10;                val obj = jsonArray.getJSONObject(i)&#10;                achievements.add(&#10;                    Achievement(&#10;                        id = obj.getString(&quot;id&quot;),&#10;                        title = obj.getString(&quot;title&quot;),&#10;                        description = obj.getString(&quot;description&quot;),&#10;                        icon = obj.getString(&quot;icon&quot;),&#10;                        isUnlocked = obj.getBoolean(&quot;isUnlocked&quot;),&#10;                        unlockedAt = if (obj.getLong(&quot;unlockedAt&quot;) == 0L) null else obj.getLong(&quot;unlockedAt&quot;),&#10;                        progress = obj.getInt(&quot;progress&quot;),&#10;                        maxProgress = obj.getInt(&quot;maxProgress&quot;)&#10;                    )&#10;                )&#10;            }&#10;            _achievements.value = achievements&#10;        } catch (e: Exception) {&#10;            e.printStackTrace()&#10;        }&#10;    }&#10;    &#10;    private fun saveGameStats() {&#10;        val jsonArray = JSONArray()&#10;        _gameStats.value.forEach { stat -&gt;&#10;            val jsonObject = JSONObject().apply {&#10;                put(&quot;gameName&quot;, stat.gameName)&#10;                put(&quot;platform&quot;, stat.platform)&#10;                put(&quot;totalPlayTime&quot;, stat.totalPlayTime)&#10;                put(&quot;lastPlayed&quot;, stat.lastPlayed)&#10;                put(&quot;timesOpened&quot;, stat.timesOpened)&#10;                put(&quot;firstPlayed&quot;, stat.firstPlayed)&#10;            }&#10;            jsonArray.put(jsonObject)&#10;        }&#10;        prefs.edit().putString(&quot;game_stats&quot;, jsonArray.toString()).apply()&#10;        &#10;        // Actualizar totales&#10;        _totalPlayTime.value = _gameStats.value.sumOf { it.totalPlayTime }&#10;        _gamesPlayed.value = _gameStats.value.size&#10;    }&#10;    &#10;    private fun loadGameStats() {&#10;        val json = prefs.getString(&quot;game_stats&quot;, null) ?: return&#10;        try {&#10;            val jsonArray = JSONArray(json)&#10;            val stats = mutableListOf&lt;GameStats&gt;()&#10;            for (i in 0 until jsonArray.length()) {&#10;                val obj = jsonArray.getJSONObject(i)&#10;                stats.add(&#10;                    GameStats(&#10;                        gameName = obj.getString(&quot;gameName&quot;),&#10;                        platform = obj.getString(&quot;platform&quot;),&#10;                        totalPlayTime = obj.getLong(&quot;totalPlayTime&quot;),&#10;                        lastPlayed = obj.getLong(&quot;lastPlayed&quot;),&#10;                        timesOpened = obj.getInt(&quot;timesOpened&quot;),&#10;                        firstPlayed = obj.getLong(&quot;firstPlayed&quot;)&#10;                    )&#10;                )&#10;            }&#10;            _gameStats.value = stats&#10;            _totalPlayTime.value = stats.sumOf { it.totalPlayTime }&#10;            _gamesPlayed.value = stats.size&#10;        } catch (e: Exception) {&#10;            e.printStackTrace()&#10;        }&#10;    }&#10;    &#10;    companion object {&#10;        @Volatile&#10;        private var instance: AchievementsManager? = null&#10;        &#10;        fun getInstance(context: Context): AchievementsManager {&#10;            return instance ?: synchronized(this) {&#10;                instance ?: AchievementsManager(context.applicationContext).also { instance = it }&#10;            }&#10;        }&#10;    }&#10;}&#10;" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/app/src/main/java/com/example/afo/themes/ThemeManager.kt">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/app/src/main/java/com/example/afo/themes/ThemeManager.kt" />
              <option name="updatedContent" value="package com.example.afo.themes&#10;&#10;import android.content.Context&#10;import androidx.compose.ui.graphics.Color&#10;import kotlinx.coroutines.flow.MutableStateFlow&#10;import kotlinx.coroutines.flow.asStateFlow&#10;&#10;data class AppTheme(&#10;    val id: String,&#10;    val name: String,&#10;    val primaryColor: Color,&#10;    val secondaryColor: Color,&#10;    val backgroundColor: Color,&#10;    val surfaceColor: Color,&#10;    val cardColor: Color,&#10;    val textPrimary: Color,&#10;    val textSecondary: Color,&#10;    val accentColor: Color,&#10;    val isDark: Boolean&#10;)&#10;&#10;object ThemePresets {&#10;    val DARK_BLUE = AppTheme(&#10;        id = &quot;dark_blue&quot;,&#10;        name = &quot;Azul Oscuro (Predeterminado)&quot;,&#10;        primaryColor = Color(0xFF4A90E2),&#10;        secondaryColor = Color(0xFF6B5CA5),&#10;        backgroundColor = Color(0xFF0A0E27),&#10;        surfaceColor = Color(0xFF1A1F3A),&#10;        cardColor = Color(0xFF252B48),&#10;        textPrimary = Color(0xFFE8E8E8),&#10;        textSecondary = Color(0xFFB0B0B0),&#10;        accentColor = Color(0xFFFFD700),&#10;        isDark = true&#10;    )&#10;    &#10;    val CYBERPUNK = AppTheme(&#10;        id = &quot;cyberpunk&quot;,&#10;        name = &quot;Cyberpunk&quot;,&#10;        primaryColor = Color(0xFFFF00FF),&#10;        secondaryColor = Color(0xFF00FFFF),&#10;        backgroundColor = Color(0xFF0D0221),&#10;        surfaceColor = Color(0xFF1A0B2E),&#10;        cardColor = Color(0xFF2E1A47),&#10;        textPrimary = Color(0xFFF0F0F0),&#10;        textSecondary = Color(0xFFB8B8D1),&#10;        accentColor = Color(0xFFFFFF00),&#10;        isDark = true&#10;    )&#10;    &#10;    val NEON_GREEN = AppTheme(&#10;        id = &quot;neon_green&quot;,&#10;        name = &quot;Verde Neón&quot;,&#10;        primaryColor = Color(0xFF39FF14),&#10;        secondaryColor = Color(0xFF00FF41),&#10;        backgroundColor = Color(0xFF0A0F0D),&#10;        surfaceColor = Color(0xFF111C18),&#10;        cardColor = Color(0xFF1A2F26),&#10;        textPrimary = Color(0xFFE0FFE0),&#10;        textSecondary = Color(0xFFB0D0B0),&#10;        accentColor = Color(0xFFFFFF00),&#10;        isDark = true&#10;    )&#10;    &#10;    val SUNSET = AppTheme(&#10;        id = &quot;sunset&quot;,&#10;        name = &quot;Atardecer&quot;,&#10;        primaryColor = Color(0xFFFF6B35),&#10;        secondaryColor = Color(0xFFFF9B42),&#10;        backgroundColor = Color(0xFF1A0D0A),&#10;        surfaceColor = Color(0xFF2D1810),&#10;        cardColor = Color(0xFF3D2318),&#10;        textPrimary = Color(0xFFFFE8D6),&#10;        textSecondary = Color(0xFFD4A88C),&#10;        accentColor = Color(0xFFFFD700),&#10;        isDark = true&#10;    )&#10;    &#10;    val OCEAN = AppTheme(&#10;        id = &quot;ocean&quot;,&#10;        name = &quot;Océano&quot;,&#10;        primaryColor = Color(0xFF00B4D8),&#10;        secondaryColor = Color(0xFF0077B6),&#10;        backgroundColor = Color(0xFF001219),&#10;        surfaceColor = Color(0xFF003049),&#10;        cardColor = Color(0xFF004E73),&#10;        textPrimary = Color(0xFFE0F4FF),&#10;        textSecondary = Color(0xFFB0D5E8),&#10;        accentColor = Color(0xFF48CAE4),&#10;        isDark = true&#10;    )&#10;    &#10;    val PURPLE_HAZE = AppTheme(&#10;        id = &quot;purple_haze&quot;,&#10;        name = &quot;Neblina Púrpura&quot;,&#10;        primaryColor = Color(0xFF9D4EDD),&#10;        secondaryColor = Color(0xFF7209B7),&#10;        backgroundColor = Color(0xFF10002B),&#10;        surfaceColor = Color(0xFF240046),&#10;        cardColor = Color(0xFF3C096C),&#10;        textPrimary = Color(0xFFF0E7FF),&#10;        textSecondary = Color(0xFFC8B6D6),&#10;        accentColor = Color(0xFFE0AAFF),&#10;        isDark = true&#10;    )&#10;    &#10;    val RETRO = AppTheme(&#10;        id = &quot;retro&quot;,&#10;        name = &quot;Retro Gaming&quot;,&#10;        primaryColor = Color(0xFFFF3864),&#10;        secondaryColor = Color(0xFF7B2CBF),&#10;        backgroundColor = Color(0xFF0F0A0A),&#10;        surfaceColor = Color(0xFF2D1B2E),&#10;        cardColor = Color(0xFF3E2A47),&#10;        textPrimary = Color(0xFFFFF1F1),&#10;        textSecondary = Color(0xFFD1B7D3),&#10;        accentColor = Color(0xFF00FFB3),&#10;        isDark = true&#10;    )&#10;    &#10;    val LIGHT_MODE = AppTheme(&#10;        id = &quot;light&quot;,&#10;        name = &quot;Modo Claro&quot;,&#10;        primaryColor = Color(0xFF1976D2),&#10;        secondaryColor = Color(0xFF0D47A1),&#10;        backgroundColor = Color(0xFFF5F5F5),&#10;        surfaceColor = Color(0xFFFFFFFF),&#10;        cardColor = Color(0xFFFFFFFF),&#10;        textPrimary = Color(0xFF212121),&#10;        textSecondary = Color(0xFF757575),&#10;        accentColor = Color(0xFFFF9800),&#10;        isDark = false&#10;    )&#10;    &#10;    val MINT = AppTheme(&#10;        id = &quot;mint&quot;,&#10;        name = &quot;Menta Fresca&quot;,&#10;        primaryColor = Color(0xFF2DD4BF),&#10;        secondaryColor = Color(0xFF14B8A6),&#10;        backgroundColor = Color(0xFFECFDF5),&#10;        surfaceColor = Color(0xFFFFFFFF),&#10;        cardColor = Color(0xFFF0FDFA),&#10;        textPrimary = Color(0xFF134E4A),&#10;        textSecondary = Color(0xFF5E7C78),&#10;        accentColor = Color(0xFFF59E0B),&#10;        isDark = false&#10;    )&#10;    &#10;    val CHERRY_BLOSSOM = AppTheme(&#10;        id = &quot;cherry&quot;,&#10;        name = &quot;Cerezo&quot;,&#10;        primaryColor = Color(0xFFEC4899),&#10;        secondaryColor = Color(0xFFDB2777),&#10;        backgroundColor = Color(0xFFFDF2F8),&#10;        surfaceColor = Color(0xFFFFFFFF),&#10;        cardColor = Color(0xFFFCE7F3),&#10;        textPrimary = Color(0xFF831843),&#10;        textSecondary = Color(0xFF9F1239),&#10;        accentColor = Color(0xFFF43F5E),&#10;        isDark = false&#10;    )&#10;    &#10;    fun getAllThemes(): List&lt;AppTheme&gt; = listOf(&#10;        DARK_BLUE,&#10;        CYBERPUNK,&#10;        NEON_GREEN,&#10;        SUNSET,&#10;        OCEAN,&#10;        PURPLE_HAZE,&#10;        RETRO,&#10;        LIGHT_MODE,&#10;        MINT,&#10;        CHERRY_BLOSSOM&#10;    )&#10;}&#10;&#10;class ThemeManager(private val context: Context) {&#10;    &#10;    private val prefs = context.getSharedPreferences(&quot;theme_prefs&quot;, Context.MODE_PRIVATE)&#10;    &#10;    private val _currentTheme = MutableStateFlow(loadTheme())&#10;    val currentTheme = _currentTheme.asStateFlow()&#10;    &#10;    fun setTheme(theme: AppTheme) {&#10;        _currentTheme.value = theme&#10;        prefs.edit().putString(&quot;selected_theme_id&quot;, theme.id).apply()&#10;    }&#10;    &#10;    fun getThemeById(id: String): AppTheme {&#10;        return ThemePresets.getAllThemes().find { it.id == id } ?: ThemePresets.DARK_BLUE&#10;    }&#10;    &#10;    private fun loadTheme(): AppTheme {&#10;        val themeId = prefs.getString(&quot;selected_theme_id&quot;, &quot;dark_blue&quot;) ?: &quot;dark_blue&quot;&#10;        return getThemeById(themeId)&#10;    }&#10;    &#10;    companion object {&#10;        @Volatile&#10;        private var instance: ThemeManager? = null&#10;        &#10;        fun getInstance(context: Context): ThemeManager {&#10;            return instance ?: synchronized(this) {&#10;                instance ?: ThemeManager(context.applicationContext).also { instance = it }&#10;            }&#10;        }&#10;    }&#10;}&#10;" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/app/src/main/java/com/example/afo/ui/screens/ProfileScreen.kt">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/app/src/main/java/com/example/afo/ui/screens/ProfileScreen.kt" />
              <option name="updatedContent" value="package com.example.afo.ui.screens&#10;&#10;import androidx.compose.animation.*&#10;import androidx.compose.animation.core.*&#10;import androidx.compose.foundation.background&#10;import androidx.compose.foundation.layout.*&#10;import androidx.compose.foundation.lazy.LazyColumn&#10;import androidx.compose.foundation.lazy.items&#10;import androidx.compose.foundation.shape.CircleShape&#10;import androidx.compose.foundation.shape.RoundedCornerShape&#10;import androidx.compose.material.icons.Icons&#10;import androidx.compose.material.icons.filled.*&#10;import androidx.compose.material3.*&#10;import androidx.compose.runtime.*&#10;import androidx.compose.ui.Alignment&#10;import androidx.compose.ui.Modifier&#10;import androidx.compose.ui.draw.alpha&#10;import androidx.compose.ui.draw.clip&#10;import androidx.compose.ui.draw.scale&#10;import androidx.compose.ui.graphics.Brush&#10;import androidx.compose.ui.graphics.Color&#10;import androidx.compose.ui.platform.LocalContext&#10;import androidx.compose.ui.text.font.FontWeight&#10;import androidx.compose.ui.text.style.TextAlign&#10;import androidx.compose.ui.unit.dp&#10;import androidx.compose.ui.unit.sp&#10;import com.example.afo.achievements.Achievement&#10;import com.example.afo.achievements.AchievementsManager&#10;import com.example.afo.achievements.GameStats&#10;import com.example.afo.ui.theme.*&#10;import java.text.SimpleDateFormat&#10;import java.util.*&#10;&#10;enum class ProfileTab {&#10;    ACHIEVEMENTS,&#10;    STATS&#10;}&#10;&#10;@OptIn(ExperimentalMaterial3Api::class)&#10;@Composable&#10;fun ProfileScreen() {&#10;    val context = LocalContext.current&#10;    val achievementsManager = remember { AchievementsManager.getInstance(context) }&#10;    &#10;    var selectedTab by remember { mutableStateOf(ProfileTab.ACHIEVEMENTS) }&#10;    &#10;    val achievements by achievementsManager.achievements.collectAsState()&#10;    val gameStats by achievementsManager.gameStats.collectAsState()&#10;    val totalPlayTime by achievementsManager.totalPlayTime.collectAsState()&#10;    val gamesPlayed by achievementsManager.gamesPlayed.collectAsState()&#10;    &#10;    val unlockedPercentage = achievementsManager.getUnlockedPercentage()&#10;    val unlockedCount = achievements.count { it.isUnlocked }&#10;    &#10;    Box(&#10;        modifier = Modifier&#10;            .fillMaxSize()&#10;            .background(DarkBackground)&#10;    ) {&#10;        Column(modifier = Modifier.fillMaxSize()) {&#10;            // Header con resumen&#10;            Surface(&#10;                modifier = Modifier.fillMaxWidth(),&#10;                color = DarkSurface,&#10;                shadowElevation = 8.dp&#10;            ) {&#10;                Column(&#10;                    modifier = Modifier&#10;                        .fillMaxWidth()&#10;                        .padding(20.dp)&#10;                ) {&#10;                    Text(&#10;                        text = &quot;Mi Perfil&quot;,&#10;                        fontSize = 28.sp,&#10;                        fontWeight = FontWeight.Black,&#10;                        color = TextPrimary&#10;                    )&#10;                    &#10;                    Spacer(modifier = Modifier.height(16.dp))&#10;                    &#10;                    // Tarjetas de resumen&#10;                    Row(&#10;                        modifier = Modifier.fillMaxWidth(),&#10;                        horizontalArrangement = Arrangement.spacedBy(12.dp)&#10;                    ) {&#10;                        StatCard(&#10;                            modifier = Modifier.weight(1f),&#10;                            icon = &quot;&quot;,&#10;                            value = gamesPlayed.toString(),&#10;                            label = &quot;Juegos&quot;&#10;                        )&#10;                        &#10;                        StatCard(&#10;                            modifier = Modifier.weight(1f),&#10;                            icon = &quot;⏱️&quot;,&#10;                            value = formatPlayTime(totalPlayTime),&#10;                            label = &quot;Tiempo&quot;&#10;                        )&#10;                        &#10;                        StatCard(&#10;                            modifier = Modifier.weight(1f),&#10;                            icon = &quot;&quot;,&#10;                            value = &quot;$unlockedCount/${achievements.size}&quot;,&#10;                            label = &quot;Logros&quot;&#10;                        )&#10;                    }&#10;                    &#10;                    Spacer(modifier = Modifier.height(16.dp))&#10;                    &#10;                    // Barra de progreso de logros&#10;                    Column {&#10;                        Row(&#10;                            modifier = Modifier.fillMaxWidth(),&#10;                            horizontalArrangement = Arrangement.SpaceBetween,&#10;                            verticalAlignment = Alignment.CenterVertically&#10;                        ) {&#10;                            Text(&#10;                                text = &quot;Progreso de Logros&quot;,&#10;                                fontSize = 14.sp,&#10;                                fontWeight = FontWeight.Medium,&#10;                                color = TextSecondary&#10;                            )&#10;                            Text(&#10;                                text = &quot;${unlockedPercentage.toInt()}%&quot;,&#10;                                fontSize = 14.sp,&#10;                                fontWeight = FontWeight.Bold,&#10;                                color = PrimaryBlue&#10;                            )&#10;                        }&#10;                        &#10;                        Spacer(modifier = Modifier.height(8.dp))&#10;                        &#10;                        LinearProgressIndicator(&#10;                            progress = { unlockedPercentage / 100f },&#10;                            modifier = Modifier&#10;                                .fillMaxWidth()&#10;                                .height(8.dp)&#10;                                .clip(RoundedCornerShape(4.dp)),&#10;                            color = PrimaryBlue,&#10;                            trackColor = DarkSurfaceVariant&#10;                        )&#10;                    }&#10;                    &#10;                    Spacer(modifier = Modifier.height(16.dp))&#10;                    &#10;                    // Tabs&#10;                    TabRow(&#10;                        selectedTabIndex = selectedTab.ordinal,&#10;                        containerColor = Color.Transparent,&#10;                        contentColor = TextPrimary&#10;                    ) {&#10;                        Tab(&#10;                            selected = selectedTab == ProfileTab.ACHIEVEMENTS,&#10;                            onClick = { selectedTab = ProfileTab.ACHIEVEMENTS },&#10;                            text = {&#10;                                Row(&#10;                                    verticalAlignment = Alignment.CenterVertically,&#10;                                    horizontalArrangement = Arrangement.spacedBy(8.dp)&#10;                                ) {&#10;                                    Icon(&#10;                                        imageVector = Icons.Filled.EmojiEvents,&#10;                                        contentDescription = null,&#10;                                        modifier = Modifier.size(18.dp)&#10;                                    )&#10;                                    Text(&quot;Logros&quot;)&#10;                                }&#10;                            },&#10;                            selectedContentColor = PrimaryBlue,&#10;                            unselectedContentColor = TextSecondary&#10;                        )&#10;                        &#10;                        Tab(&#10;                            selected = selectedTab == ProfileTab.STATS,&#10;                            onClick = { selectedTab = ProfileTab.STATS },&#10;                            text = {&#10;                                Row(&#10;                                    verticalAlignment = Alignment.CenterVertically,&#10;                                    horizontalArrangement = Arrangement.spacedBy(8.dp)&#10;                                ) {&#10;                                    Icon(&#10;                                        imageVector = Icons.Filled.Insights,&#10;                                        contentDescription = null,&#10;                                        modifier = Modifier.size(18.dp)&#10;                                    )&#10;                                    Text(&quot;Estadísticas&quot;)&#10;                                }&#10;                            },&#10;                            selectedContentColor = PrimaryBlue,&#10;                            unselectedContentColor = TextSecondary&#10;                        )&#10;                    }&#10;                }&#10;            }&#10;            &#10;            // Contenido según tab&#10;            AnimatedContent(&#10;                targetState = selectedTab,&#10;                label = &quot;profileTabs&quot;&#10;            ) { tab -&gt;&#10;                when (tab) {&#10;                    ProfileTab.ACHIEVEMENTS -&gt; {&#10;                        AchievementsContent(achievements = achievements)&#10;                    }&#10;                    ProfileTab.STATS -&gt; {&#10;                        StatsContent(&#10;                            gameStats = gameStats,&#10;                            achievementsManager = achievementsManager&#10;                        )&#10;                    }&#10;                }&#10;            }&#10;        }&#10;    }&#10;}&#10;&#10;@Composable&#10;private fun StatCard(&#10;    modifier: Modifier = Modifier,&#10;    icon: String,&#10;    value: String,&#10;    label: String&#10;) {&#10;    Card(&#10;        modifier = modifier,&#10;        colors = CardDefaults.cardColors(&#10;            containerColor = CardBackground&#10;        ),&#10;        shape = RoundedCornerShape(12.dp)&#10;    ) {&#10;        Column(&#10;            modifier = Modifier&#10;                .fillMaxWidth()&#10;                .padding(12.dp),&#10;            horizontalAlignment = Alignment.CenterHorizontally&#10;        ) {&#10;            Text(&#10;                text = icon,&#10;                fontSize = 32.sp&#10;            )&#10;            Spacer(modifier = Modifier.height(4.dp))&#10;            Text(&#10;                text = value,&#10;                fontSize = 20.sp,&#10;                fontWeight = FontWeight.Bold,&#10;                color = TextPrimary&#10;            )&#10;            Text(&#10;                text = label,&#10;                fontSize = 12.sp,&#10;                color = TextSecondary&#10;            )&#10;        }&#10;    }&#10;}&#10;&#10;@Composable&#10;private fun AchievementsContent(achievements: List&lt;Achievement&gt;) {&#10;    if (achievements.isEmpty()) {&#10;        EmptyState(&#10;            icon = Icons.Filled.EmojiEvents,&#10;            title = &quot;Sin logros aún&quot;,&#10;            message = &quot;Juega para desbloquear logros y coleccionar trofeos&quot;&#10;        )&#10;    } else {&#10;        LazyColumn(&#10;            contentPadding = PaddingValues(16.dp),&#10;            verticalArrangement = Arrangement.spacedBy(8.dp)&#10;        ) {&#10;            // Logros desbloqueados&#10;            val unlocked = achievements.filter { it.isUnlocked }&#10;            val locked = achievements.filter { !it.isUnlocked }&#10;            &#10;            if (unlocked.isNotEmpty()) {&#10;                item {&#10;                    Text(&#10;                        text = &quot;DESBLOQUEADOS (${unlocked.size})&quot;,&#10;                        fontSize = 12.sp,&#10;                        fontWeight = FontWeight.Bold,&#10;                        color = SuccessGreen,&#10;                        modifier = Modifier.padding(vertical = 8.dp)&#10;                    )&#10;                }&#10;                &#10;                items(unlocked) { achievement -&gt;&#10;                    AchievementCard(achievement = achievement, isUnlocked = true)&#10;                }&#10;            }&#10;            &#10;            if (locked.isNotEmpty()) {&#10;                item {&#10;                    Text(&#10;                        text = &quot;BLOQUEADOS (${locked.size})&quot;,&#10;                        fontSize = 12.sp,&#10;                        fontWeight = FontWeight.Bold,&#10;                        color = TextSecondary,&#10;                        modifier = Modifier.padding(top = 16.dp, bottom = 8.dp)&#10;                    )&#10;                }&#10;                &#10;                items(locked) { achievement -&gt;&#10;                    AchievementCard(achievement = achievement, isUnlocked = false)&#10;                }&#10;            }&#10;        }&#10;    }&#10;}&#10;&#10;@Composable&#10;private fun AchievementCard(&#10;    achievement: Achievement,&#10;    isUnlocked: Boolean&#10;) {&#10;    val animatedScale by animateFloatAsState(&#10;        targetValue = if (isUnlocked) 1f else 0.95f,&#10;        animationSpec = spring(&#10;            dampingRatio = Spring.DampingRatioMediumBouncy,&#10;            stiffness = Spring.StiffnessLow&#10;        ),&#10;        label = &quot;achievementScale&quot;&#10;    )&#10;    &#10;    Card(&#10;        modifier = Modifier&#10;            .fillMaxWidth()&#10;            .scale(animatedScale)&#10;            .alpha(if (isUnlocked) 1f else 0.6f),&#10;        colors = CardDefaults.cardColors(&#10;            containerColor = if (isUnlocked) &#10;                CardBackground &#10;            else &#10;                DarkSurfaceVariant&#10;        ),&#10;        shape = RoundedCornerShape(12.dp)&#10;    ) {&#10;        Row(&#10;            modifier = Modifier&#10;                .fillMaxWidth()&#10;                .padding(16.dp),&#10;            horizontalArrangement = Arrangement.spacedBy(16.dp),&#10;            verticalAlignment = Alignment.CenterVertically&#10;        ) {&#10;            // Icono del logro&#10;            Box(&#10;                modifier = Modifier&#10;                    .size(64.dp)&#10;                    .clip(CircleShape)&#10;                    .background(&#10;                        if (isUnlocked) &#10;                            PrimaryBlue.copy(alpha = 0.2f) &#10;                        else &#10;                            Color.Gray.copy(alpha = 0.1f)&#10;                    ),&#10;                contentAlignment = Alignment.Center&#10;            ) {&#10;                Text(&#10;                    text = achievement.icon,&#10;                    fontSize = 32.sp&#10;                )&#10;            }&#10;            &#10;            // Info del logro&#10;            Column(&#10;                modifier = Modifier.weight(1f)&#10;            ) {&#10;                Row(&#10;                    verticalAlignment = Alignment.CenterVertically,&#10;                    horizontalArrangement = Arrangement.spacedBy(8.dp)&#10;                ) {&#10;                    Text(&#10;                        text = achievement.title,&#10;                        fontSize = 16.sp,&#10;                        fontWeight = FontWeight.Bold,&#10;                        color = if (isUnlocked) TextPrimary else TextSecondary&#10;                    )&#10;                    &#10;                    if (isUnlocked) {&#10;                        Icon(&#10;                            imageVector = Icons.Filled.CheckCircle,&#10;                            contentDescription = &quot;Desbloqueado&quot;,&#10;                            tint = SuccessGreen,&#10;                            modifier = Modifier.size(20.dp)&#10;                        )&#10;                    }&#10;                }&#10;                &#10;                Text(&#10;                    text = achievement.description,&#10;                    fontSize = 13.sp,&#10;                    color = TextSecondary,&#10;                    modifier = Modifier.padding(top = 4.dp)&#10;                )&#10;                &#10;                if (achievement.unlockedAt != null) {&#10;                    Text(&#10;                        text = &quot;Desbloqueado: ${formatDate(achievement.unlockedAt)}&quot;,&#10;                        fontSize = 11.sp,&#10;                        color = TextTertiary,&#10;                        modifier = Modifier.padding(top = 4.dp)&#10;                    )&#10;                } else if (achievement.maxProgress &gt; 1) {&#10;                    // Mostrar progreso&#10;                    Column(modifier = Modifier.padding(top = 8.dp)) {&#10;                        Text(&#10;                            text = &quot;${achievement.progress}/${achievement.maxProgress}&quot;,&#10;                            fontSize = 11.sp,&#10;                            color = TextSecondary&#10;                        )&#10;                        LinearProgressIndicator(&#10;                            progress = { achievement.progress.toFloat() / achievement.maxProgress.toFloat() },&#10;                            modifier = Modifier&#10;                                .fillMaxWidth()&#10;                                .height(4.dp)&#10;                                .clip(RoundedCornerShape(2.dp)),&#10;                            color = PrimaryBlue,&#10;                            trackColor = DarkSurfaceVariant&#10;                        )&#10;                    }&#10;                }&#10;            }&#10;        }&#10;    }&#10;}&#10;&#10;@Composable&#10;private fun StatsContent(&#10;    gameStats: List&lt;GameStats&gt;,&#10;    achievementsManager: AchievementsManager&#10;) {&#10;    if (gameStats.isEmpty()) {&#10;        EmptyState(&#10;            icon = Icons.Filled.Insights,&#10;            title = &quot;Sin estadísticas&quot;,&#10;            message = &quot;Empieza a jugar para ver tus estadísticas de juego&quot;&#10;        )&#10;    } else {&#10;        LazyColumn(&#10;            contentPadding = PaddingValues(16.dp),&#10;            verticalArrangement = Arrangement.spacedBy(16.dp)&#10;        ) {&#10;            // Juegos más jugados&#10;            item {&#10;                Text(&#10;                    text = &quot;JUEGOS MÁS JUGADOS&quot;,&#10;                    fontSize = 14.sp,&#10;                    fontWeight = FontWeight.Bold,&#10;                    color = TextSecondary&#10;                )&#10;            }&#10;            &#10;            val mostPlayed = achievementsManager.getMostPlayedGames(5)&#10;            items(mostPlayed) { stat -&gt;&#10;                GameStatCard(stat = stat)&#10;            }&#10;            &#10;            // Juegos recientes&#10;            item {&#10;                Spacer(modifier = Modifier.height(8.dp))&#10;                Text(&#10;                    text = &quot;JUGADOS RECIENTEMENTE&quot;,&#10;                    fontSize = 14.sp,&#10;                    fontWeight = FontWeight.Bold,&#10;                    color = TextSecondary&#10;                )&#10;            }&#10;            &#10;            val recent = achievementsManager.getRecentGames(5)&#10;            items(recent) { stat -&gt;&#10;                GameStatCard(stat = stat, showLastPlayed = true)&#10;            }&#10;        }&#10;    }&#10;}&#10;&#10;@Composable&#10;private fun GameStatCard(&#10;    stat: GameStats,&#10;    showLastPlayed: Boolean = false&#10;) {&#10;    Card(&#10;        modifier = Modifier.fillMaxWidth(),&#10;        colors = CardDefaults.cardColors(&#10;            containerColor = CardBackground&#10;        ),&#10;        shape = RoundedCornerShape(12.dp)&#10;    ) {&#10;        Row(&#10;            modifier = Modifier&#10;                .fillMaxWidth()&#10;                .padding(16.dp),&#10;            horizontalArrangement = Arrangement.spacedBy(12.dp),&#10;            verticalAlignment = Alignment.CenterVertically&#10;        ) {&#10;            // Indicador de plataforma&#10;            Surface(&#10;                modifier = Modifier.size(48.dp),&#10;                shape = RoundedCornerShape(8.dp),&#10;                color = PrimaryBlue.copy(alpha = 0.2f)&#10;            ) {&#10;                Box(contentAlignment = Alignment.Center) {&#10;                    Text(&#10;                        text = stat.platform.take(3).uppercase(),&#10;                        fontSize = 14.sp,&#10;                        fontWeight = FontWeight.Bold,&#10;                        color = PrimaryBlue&#10;                    )&#10;                }&#10;            }&#10;            &#10;            // Info del juego&#10;            Column(&#10;                modifier = Modifier.weight(1f)&#10;            ) {&#10;                Text(&#10;                    text = stat.gameName,&#10;                    fontSize = 15.sp,&#10;                    fontWeight = FontWeight.Bold,&#10;                    color = TextPrimary,&#10;                    maxLines = 1&#10;                )&#10;                &#10;                Row(&#10;                    horizontalArrangement = Arrangement.spacedBy(12.dp),&#10;                    modifier = Modifier.padding(top = 4.dp)&#10;                ) {&#10;                    Text(&#10;                        text = &quot;⏱️ ${formatPlayTime(stat.totalPlayTime)}&quot;,&#10;                        fontSize = 12.sp,&#10;                        color = TextSecondary&#10;                    )&#10;                    &#10;                    Text(&#10;                        text = &quot; ${stat.timesOpened}x&quot;,&#10;                        fontSize = 12.sp,&#10;                        color = TextSecondary&#10;                    )&#10;                }&#10;                &#10;                if (showLastPlayed) {&#10;                    Text(&#10;                        text = &quot;Hace ${formatTimeAgo(stat.lastPlayed)}&quot;,&#10;                        fontSize = 11.sp,&#10;                        color = TextTertiary,&#10;                        modifier = Modifier.padding(top = 2.dp)&#10;                    )&#10;                }&#10;            }&#10;        }&#10;    }&#10;}&#10;&#10;private fun formatPlayTime(ms: Long): String {&#10;    val hours = ms / (1000 * 60 * 60)&#10;    val minutes = (ms % (1000 * 60 * 60)) / (1000 * 60)&#10;    &#10;    return when {&#10;        hours &gt; 0 -&gt; &quot;${hours}h ${minutes}m&quot;&#10;        minutes &gt; 0 -&gt; &quot;${minutes}m&quot;&#10;        else -&gt; &quot;&lt; 1m&quot;&#10;    }&#10;}&#10;&#10;private fun formatDate(timestamp: Long): String {&#10;    val sdf = SimpleDateFormat(&quot;dd/MM/yyyy&quot;, Locale.getDefault())&#10;    return sdf.format(Date(timestamp))&#10;}&#10;&#10;private fun formatTimeAgo(timestamp: Long): String {&#10;    val now = System.currentTimeMillis()&#10;    val diff = now - timestamp&#10;    &#10;    val minutes = diff / (1000 * 60)&#10;    val hours = diff / (1000 * 60 * 60)&#10;    val days = diff / (1000 * 60 * 60 * 24)&#10;    &#10;    return when {&#10;        minutes &lt; 60 -&gt; &quot;$minutes minutos&quot;&#10;        hours &lt; 24 -&gt; &quot;$hours horas&quot;&#10;        days &lt; 7 -&gt; &quot;$days días&quot;&#10;        else -&gt; &quot;${days / 7} semanas&quot;&#10;    }&#10;}&#10;" />
            </PendingDiffInfo>
          </value>
        </entry>
      </map>
    </option>
  </component>
</project>